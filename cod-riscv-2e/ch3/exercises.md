**3.1**

5730

**3.2**

5730

**3.3**

0101111011010100

**3.4**

0753

**3.5**

7777

**3.6**

63

**3.7**

65

**3.8**

-179 (overflow)

**3.9**

(-105) + (-42) = -147 (saturated at -128)

**3.10**

(-105) - (-42) = -63

**3.11**

151 + 214 = 365 (saturated at 256)

**3.12**

| Iteration | Step               | Multiplier | Multiplicand | Product      |
| --------- | ------------------ | ---------- | ------------ | ------------ |
| 0         | Initial values     | 001010     | 000000110010 | 000000000000 |
| 1         | 1 => Prod += Mcand | 001010     | 000000110010 | 000000000000 |
| 1         | Shift left Mcand   | 001010     | 000001100100 | 000000000000 |
| 1         | Shift right Mlier  | 000101     | 000001100100 | 000000000000 |
| 2         | 1 => Prod += Mcand | 000101     | 000001100100 | 000001100100 |
| 2         | Shift left Mcand   | 000101     | 000011001000 | 000001100100 |
| 2         | Shift right Mlier  | 000010     | 000011001000 | 000001100100 |
| 3         | 1 => Prod += Mcand | 000010     | 000011001000 | 000001100100 |
| 3         | Shift left Mcand   | 000010     | 000110010000 | 000001100100 |
| 3         | Shift right Mlier  | 000001     | 000110010000 | 000001100100 |
| 4         | 1 => Prod += Mcand | 000001     | 000110010000 | 000111110100 |
| 4         | Shift left Mcand   | 000001     | 001100100000 | 000111110100 |
| 4         | Shift right Mlier  | 000000     | 001100100000 | 000111110100 |

**3.13**

| Iteration | Step               | Multiplicand | Product/Multiplier |
| --------- | ------------------ | ------------ | ------------------ |
| 0         | Initial values     | 110010       | 000000001010       |
| 1         | 1 => Prod += Mcand | 110010       | 000000001010       |
| 1         | Shift right Prod   | 110010       | 000000000101       |
| 2         | 1 => Prod += Mcand | 110010       | 110010000101       |
| 2         | Shift right Prod   | 110010       | 011001000010       |
| 3         | 1 => Prod += Mcand | 110010       | 011001000010       |
| 3         | Shift right Prod   | 110010       | 001100100001       |
| 4         | 1 => Prod += Mcand | 110010       | 111110100001       |
| 4         | Shift right Prod   | 110010       | 011111010000       |
| 5         | 1 => Prod += Mcand | 110010       | 011111010000       |
| 5         | Shift right Prod   | 110010       | 001111101000       |
| 6         | 1 => Prod += Mcand | 110010       | 001111101000       |
| 6         | Shift right Prod   | 110010       | 000111110100       |

**3.14**

The hardware executes add, shift, and comparison for each iteration.
`3 cycle/iter * 8 iter * 4 tu/cycle = 96 tu`.

The software executes add, 2 shifts, and comparison for each iteration.
`4 cycle/iter * 8 iter * 4 tu/cycle = 128 tu`.

**3.15**

7 adders stacked vertically.
`4 tu * 7 = 28 tu`.

**3.16**

7 adders form 4 levels vertically.
`4 tu * 3 = 12 tu`.

**3.17**

- `0x33 = 00110011`. When 0x33 is multiplier, 3 shifts and 3 adds.
- `0x55 = 01010101`. When 0x55 is multiplier, 3 shifts and 3 adds.

**3.18**

| Iteration | Step                 | Quotient | Divisor      | Remainder    |
| --------- | -------------------- | -------- | ------------ | ------------ |
| 0         | Initial values       | 000000   | 010001000000 | 000000111100 |
| 1         | Rem -= Div           | 000000   | 010001000000 | 101111111100 |
| 1         | Rem += Div or Q0 = 1 | 000000   | 010001000000 | 000000111100 |
| 1         | Shift right Div      | 000000   | 001000100000 | 000000111100 |
| 2         | Rem -= Div           | 000000   | 001000100000 | 111000011100 |
| 2         | Rem += Div or Q0 = 1 | 000000   | 001000100000 | 000000111100 |
| 2         | Shift right Div      | 000000   | 000100010000 | 000000111100 |
| 3         | Rem -= Div           | 000000   | 000100010000 | 111100101100 |
| 3         | Rem += Div or Q0 = 1 | 000000   | 000100010000 | 000000111100 |
| 3         | Shift right Div      | 000000   | 000010001000 | 000000111100 |
| 4         | Rem -= Div           | 000000   | 000010001000 | 111110110100 |
| 4         | Rem += Div or Q0 = 1 | 000000   | 000010001000 | 000000111100 |
| 4         | Shift right Div      | 000000   | 000001000100 | 000000111100 |
| 5         | Rem -= Div           | 000000   | 000001000100 | 111111111000 |
| 5         | Rem += Div or Q0 = 1 | 000000   | 000001000100 | 000000111100 |
| 5         | Shift right Div      | 000000   | 000000100010 | 000000111100 |
| 6         | Rem -= Div           | 000000   | 000000100010 | 000000011010 |
| 6         | Rem += Div or Q0 = 1 | 000001   | 000000100010 | 000000011010 |
| 6         | Shift right Div      | 000001   | 000000010001 | 000000011010 |
| 7         | Rem -= Div           | 000001   | 000000010001 | 000000001001 |
| 7         | Rem += Div or Q0 = 1 | 000011   | 000000010001 | 000000001001 |
| 7         | Shift right Div      | 000011   | 000000001000 | 000000001001 |

**3.19**

| Iteration | Step                 | Divisor | Remainder / Quotient |
| --------- | -------------------- | ------- | -------------------- |
| 0         | Initial values       | 010001  | 000000111100         |
| 1         | Shift left Rem       | 010001  | 000001111000         |
| 1         | Rem -= Div           | 010001  | 110000111000         |
| 1         | Rem += Div or Q0 = 1 | 010001  | 000001111000         |
| 2         | Shift left Rem       | 010001  | 000011110000         |
| 2         | Rem -= Div           | 010001  | 110010110000         |
| 2         | Rem += Div or Q0 = 1 | 010001  | 000011110000         |
| 3         | Shift left Rem       | 010001  | 000111100000         |
| 3         | Rem -= Div           | 010001  | 110110100000         |
| 3         | Rem += Div or Q0 = 1 | 010001  | 000111100000         |
| 4         | Shift left Rem       | 010001  | 001111000000         |
| 4         | Rem -= Div           | 010001  | 111110000000         |
| 4         | Rem += Div or Q0 = 1 | 010001  | 001111000000         |
| 5         | Shift left Rem       | 010001  | 011110000000         |
| 5         | Rem -= Div           | 010001  | 001101000000         |
| 5         | Rem += Div or Q0 = 1 | 010001  | 001101000001         |
| 6         | Shift left Rem       | 010001  | 011010000010         |
| 6         | Rem -= Div           | 010001  | 001001000010         |
| 6         | Rem += Div or Q0 = 1 | 010001  | 001001000011         |

**3.20**

`0x0C000000 = 201326592`.

**3.21**

`jal x0, 0`.

**3.22**

`1.0 * 2 ^ -103`.

**3.23**

`01000010011111010000000000000000`.

**3.24**

`0100000001001111101000000000000000000000000000000000000000000000`.

**3.25**

`01000010001111110100000000000000`.

**3.26**

TODO(rexes-ND): Study DEC PDP-8 floating point format.

**3.27**

`1011000100000000`

**3.28**

TODO(rexes-ND): Study Hewlett-Packard floating point format.

**3.29**

`2.6125 * 10 ^ 1 = 26.125 = 1.1010001 * 2 ^ 4 = 0|10011|1010001000`.

`4.150390625 × 10 ^ −1 = 0.4150390625 = 1.10101001 * 2 ^ -2 = 0|01101|1010100100`.

- `1.1010001000 = 1.1010001000 (G: 0, R: 0, S: 0)`.
- `0.00000110101001 = 0.0000011010 (G: 1, R: 0, S: 1)`.
- `1.1010100011`

`1.1010100011 * 2 ^ 4 = 11010.100011 = 26.546875`.

**3.30**

`-8.0546875 = -1 * 1.0000000111 * 2 ^ 3`.

`-0.179931640625 = -1 * 1.0111000010 * 2 ^ -3`.
`1.0000000111 * 1.0111000010 = 1.01110011000001001110 (G: 0, R: 0, S: 1)`.

`1.0111001100 * 2 ^ 0 = 1.44921875`.

**3.31**

`86.25 = 1.01011001 * 2 ^ 6`.

`-4.875 = -1 * 1.00111 * 2 ^ 2`.

`1.0101100100 / 1.0011100000 = 1.000110110001001 (G: 0, R: 1, S: 1)`.

`-1 * 1.0001101100 * 2 ^ 4 = -10001.101100 = -17.6875`.

**3.32**

`(0.3984375 + 0.34375) + 1771.0`.

`0.3984375 = 1.10011 * 2 ^ -2`.

`0.34375 = 1.011 * 2 ^ - 2`.

`1771.0 = 1.1011101011 * 2 ^ 10`.

`0.3984375 + 0.34375 = 10.11111 * 2 ^ -2 = 1.011111 * 2 ^ -1`.

`1.011111 * 2 ^ -1 = 0.00000000001011111 * 2 ^ 10 = 0.0000000001 (G: 1, R: 0, S: 1)`.

The answer is `1.1011101100 * 2 ^ 10 = 1772`.

**3.33**

`0.3984375 + (0.34375 + 1771.0)`.

`0.3984375 = 1.10011 * 2 ^ -2`.

`0.34375 = 1.011 * 2 ^ - 2`.

`1771.0 = 1.1011101011 * 2 ^ 10`.

The answer is `1.1011101011 * 2 ^ 10 = 1771`.

**3.34**

No.

**3.35**

`0.00341796875 = 1.11 * 2 ^ -9`.

`0.00634765625 = 1.101 * 2 ^ -8`.

`105.625 = 1.101001101 * 2 ^ 6`.

`0.00341796875 * 0.00634765625 = 1.011011 * 2 ^ -17`.

Underflow: Too small to represent.

**3.36**

`0.00634765625 * 105.625 = 1.0101011101 * 2 ^ -1`.

The answer is `1.0010110001 * 2 ^ -9`.

**3.37**

No.

**3.38**

`1.666015625 = 1.1010101010`.

`19760.0 = 1.0011010011 * 2 ^ 14`.

`-19744.0 = -1 * 1.0011010010 * 2 ^ 14`.

`19760.0 - 19744.0 = 0.0000000001 * 2 ^ 14 = 1.0 * 2 ^ 4`.

The answer is `1.1010101010 * 2 ^ 4`.

**3.39**

`1.666015625 * 19760.0 = 1.0000000101 * 2 ^ 15`.

`1.666015625 * -19744.0 = -1.0000000100 * 2 ^ 15`.

`0.0000000001 * 2 ^ 15 = 1.0 * 2 ^ 5`.

**3.40**

No.

**3.41**

`-1/4 = -1 * 1.0 * 2 ^ -2` (Exact).

`10111110100000000000000000000000`.

**3.42**

`-1 * 1.0 * 2 ^ -2 + -1 * 1.0 * 2 ^ -2 = -1 * 10.0 * 2 ^ -2 = -1 * 1.0 + 2 ^ -1`.

`-1 * 1.0 * 2 ^ -1 + -1 * 1.0 * 2 ^ -2 = -1 * 1.1 * 2 ^ -1`.

`-1 * 1.1 * 2 ^ -1 + -1 * 1.0 * 2 ^ -2 = -1 * 1.0 * 2 ^ 0`.

Both multiplication and additions are exact.

**3.43**

`-1/3 = -1 * 1.010101010101010101 * 2 ^ -2` (Not exact).

**3.44**

`001100110011001100110011` (Not exact).

**3.45**

`001100110011001100110011` (Not exact).

**3.46**

`00011000110001100011` (Not exact).

**3.47**

```c
for (i = 3; i < 128; ++i)
    sig_out[i] =
        sig_in[i − 3] * f[0]
        + sig_in[i − 2] * f[1]
        + sig_in[i − 1] * f[2]
        + sig_in[i] * f[3];
```

```c
reg0 = sig_in[0:7];
F = f[0:4];
F <<= 64;
F |= f[0:4];
for (i = 3; i < 8; ++i) {
    reg1 = (reg0 << (i - 3)) * F;
    for (j = 0; j < 3; ++j) {
        reg1[3] += reg1[j];
    }
    sig_out[i] = reg1[3];
}
for (i = 1; i < 8; ++i) {
    reg1 = sig_in[8*i:8*i+7];
    reg3 = 0;
    for (j = 0; j < 4; ++j) {
        reg2 = (reg0 << ((5 + i) * 16)) | (reg1 >> ((3-i) * 16));
        for (k = 0; k < 4; ++k) {
            reg3[j] += reg2[k];
            reg3[4+j] += reg2[4+k];
        }
    }
    sig_out[8*i:8*i+7] = reg3;
    reg0 = reg1;
}
```
